% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pipeline.R
\docType{class}
\name{Pipeline}
\alias{Pipeline}
\title{Pipeline Class}
\description{
This class implements an analysis pipeline. A pipeline consists
of a sequence of analysis steps, which can be added one by one. Each added
step may or may not depend on one or more previous steps. The pipeline
keeps track of the dependencies among these steps and will ensure that
all dependencies are met on creation of the pipeline, that is, before the
the pipeline is executed. Once the pipeline is executed, the output is
stored in the pipeline along with each step and can be accessed later.
Different pipelines can be bound together while preserving all dependencies
within each pipeline.
}
\author{
Roman Pahl
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{name}}{`string` name of the pipeline}

\item{\code{pipeline}}{`data.table` the pipeline where each row represents on step.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-Pipeline-new}{\code{Pipeline$new()}}
\item \href{#method-Pipeline-add}{\code{Pipeline$add()}}
\item \href{#method-Pipeline-append}{\code{Pipeline$append()}}
\item \href{#method-Pipeline-collect_out}{\code{Pipeline$collect_out()}}
\item \href{#method-Pipeline-discard_steps}{\code{Pipeline$discard_steps()}}
\item \href{#method-Pipeline-execute}{\code{Pipeline$execute()}}
\item \href{#method-Pipeline-get_data}{\code{Pipeline$get_data()}}
\item \href{#method-Pipeline-get_parameters}{\code{Pipeline$get_parameters()}}
\item \href{#method-Pipeline-get_parameters_at_step}{\code{Pipeline$get_parameters_at_step()}}
\item \href{#method-Pipeline-get_step}{\code{Pipeline$get_step()}}
\item \href{#method-Pipeline-get_step_names}{\code{Pipeline$get_step_names()}}
\item \href{#method-Pipeline-get_unique_parameters}{\code{Pipeline$get_unique_parameters()}}
\item \href{#method-Pipeline-get_unique_parameters_json}{\code{Pipeline$get_unique_parameters_json()}}
\item \href{#method-Pipeline-keep_all_out}{\code{Pipeline$keep_all_out()}}
\item \href{#method-Pipeline-length}{\code{Pipeline$length()}}
\item \href{#method-Pipeline-print}{\code{Pipeline$print()}}
\item \href{#method-Pipeline-pop_step}{\code{Pipeline$pop_step()}}
\item \href{#method-Pipeline-pop_steps_after}{\code{Pipeline$pop_steps_after()}}
\item \href{#method-Pipeline-pop_steps_from}{\code{Pipeline$pop_steps_from()}}
\item \href{#method-Pipeline-remove_step}{\code{Pipeline$remove_step()}}
\item \href{#method-Pipeline-replace_step}{\code{Pipeline$replace_step()}}
\item \href{#method-Pipeline-set_common_parameters}{\code{Pipeline$set_common_parameters()}}
\item \href{#method-Pipeline-set_data}{\code{Pipeline$set_data()}}
\item \href{#method-Pipeline-set_data_split}{\code{Pipeline$set_data_split()}}
\item \href{#method-Pipeline-set_parameters_at_step}{\code{Pipeline$set_parameters_at_step()}}
\item \href{#method-Pipeline-clone}{\code{Pipeline$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-new"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-new}{}}}
\subsection{Method \code{new()}}{
constructor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$new(name, data = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{the name of the Pipeline}

\item{\code{data}}{optional data used in the pipeline (can be set later)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the `Pipeline` object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-add"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-add}{}}}
\subsection{Method \code{add()}}{
Add pipeline step
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$add(
  name,
  fun,
  params = NULL,
  description = "",
  group = name,
  keepOut = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{`string` the name of the step. Each step name must be
unique.}

\item{\code{fun}}{`string` or `function` operation to be applied at the
step. Both existing and lambda/anonymous functions can be used.}

\item{\code{params}}{`list` list of parameters to overwrite default
parameters of existing functions.}

\item{\code{description}}{`string` optional description of the step}

\item{\code{group}}{`string` grouping information (by default the same as
the name of the step. Any output collected later (see function
`collect_out` by default is put together by these group names. This,
for example, comes in handy when the pipeline is copy-appended
multiple times to keep the results of the same function/step at one
place.}

\item{\code{keepOut}}{`logical` if `FALSE` the output of the function will
be cleaned at the end of the whole pipeline execution. This option
is used to only keep the results that matter.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the `Pipeline` object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-append"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-append}{}}}
\subsection{Method \code{append()}}{
Append another pipeline. The append takes care of name
clashes and dependencies, which will be changed after the append.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$append(p, outAsIn = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{p}}{`Pipeline` object to be appended.}

\item{\code{outAsIn}}{`logical` if `TRUE`, output of first pipeline is used
as data input of appended pipeline.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns new combined `Pipeline`.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-collect_out"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-collect_out}{}}}
\subsection{Method \code{collect_out()}}{
Collect all output that was stored and kept during the
pipeline execution.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$collect_out(groupBy = "group")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{groupBy}}{`string` column of pipeline by which to group the
output.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
`list` containing the output, named after the groups, which,
by default, are the steps.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-discard_steps"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-discard_steps}{}}}
\subsection{Method \code{discard_steps()}}{
Discard all steps that match the given `pattern`.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$discard_steps(pattern, fixed = TRUE, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pattern}}{`string` containing a regular expression (or
character string for `fixed = TRUE`) to be matched.}

\item{\code{fixed}}{`logical` If `TRUE`, `pattern` is a string to
be matched as is. Overrides all conflicting arguments.}

\item{\code{...}}{further arguments passed to `[grep()]`.
#' @seealso `[grep()]`}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the `Pipeline` object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-execute"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-execute}{}}}
\subsection{Method \code{execute()}}{
Execute pipeline steps.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$execute(from = 1, to = self$length())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{from}}{`numeric` start from this step}

\item{\code{to}}{`numeric` execute until this step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the `Pipeline` object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_data"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_data}{}}}
\subsection{Method \code{get_data()}}{
Get data currently loaded into the pipeline at step 1.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_data()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
returns the data
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_parameters"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_parameters}{}}}
\subsection{Method \code{get_parameters()}}{
Get all function parameters defined in the pipeline.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_parameters(ignoreHidden = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ignoreHidden}}{`logical` if TRUE, hidden parameters (i.e. all
names starting with a dot) are ignored and thus not returned.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
`list` of parameters, sorted and named by step. Steps with
no parameters are filtered out.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_parameters_at_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_parameters_at_step}{}}}
\subsection{Method \code{get_parameters_at_step()}}{
Get all function parameters at given step name.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_parameters_at_step(name, ignoreHidden = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{`string` name of step}

\item{\code{ignoreHidden}}{`logical` if TRUE, hidden parameters (i.e. all
names starting with a dot) are ignored and thus not returned.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
`list` of parameters defined at given step.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_step}{}}}
\subsection{Method \code{get_step()}}{
Get step of pipeline
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_step(name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{`string` name of step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
`data.table` row containing the step. If step not found, an
error is given.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_step_names"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_step_names}{}}}
\subsection{Method \code{get_step_names()}}{
Get step names of pipeline
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_step_names()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
`character` vector of step names
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_unique_parameters"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_unique_parameters}{}}}
\subsection{Method \code{get_unique_parameters()}}{
Get all function parameters defined in the pipeline,
but only list each parameter once, that is, once a parameter is used
in a step, it is ignored in the listings of later steps.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_unique_parameters(ignoreHidden = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ignoreHidden}}{`logical` if TRUE, hidden parameters (i.e. all
names starting with a dot) are ignored and thus not returned.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
`list` of unique parameters, sorted and named by step. Steps
with no parameters are filtered out.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_unique_parameters_json"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_unique_parameters_json}{}}}
\subsection{Method \code{get_unique_parameters_json()}}{
Get all unique function parameters in json format.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_unique_parameters_json(ignoreHidden = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ignoreHidden}}{`logical` if TRUE, hidden parameters (i.e. all
names starting with a dot) are ignored and thus not returned.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
`list` flat unnamed json list of unique function parameters,
 at this point with no information of the steps were parameters are
 defined first.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-keep_all_out"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-keep_all_out}{}}}
\subsection{Method \code{keep_all_out()}}{
Set pipeline to keep all output regardless of the flags
that were set for the individual steps. This can be useful for
debugging.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$keep_all_out()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
`logical` original set of output flags.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-length"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-length}{}}}
\subsection{Method \code{length()}}{
Length of the pipeline aka number of pipeline steps.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$length()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
`numeric` length of pipeline.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-print"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-print}{}}}
\subsection{Method \code{print()}}{
Print the pipeline.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-pop_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-pop_step}{}}}
\subsection{Method \code{pop_step()}}{
Remove last step from the pipeline.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$pop_step()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
`string` the name of the step that was removed
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-pop_steps_after"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-pop_steps_after}{}}}
\subsection{Method \code{pop_steps_after()}}{
Remove all steps after the given step.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$pop_steps_after(name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{`string` name of step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
`character` vector of steps that were removed.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-pop_steps_from"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-pop_steps_from}{}}}
\subsection{Method \code{pop_steps_from()}}{
Remove all steps from and including the given step.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$pop_steps_from(name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{`string` name of step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
`character` vector of steps that were removed.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-remove_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-remove_step}{}}}
\subsection{Method \code{remove_step()}}{
Remove certain step from the pipeline. If step does
not exist, an error is given.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$remove_step(name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{`string` the name of the step to be removed.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the `Pipeline` object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-replace_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-replace_step}{}}}
\subsection{Method \code{replace_step()}}{
Replace pipeline step
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$replace_step(
  name,
  fun,
  params = NULL,
  description = "",
  group = name,
  keepOut = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{`string` the name of the step to be replaced. Step must
exist.}

\item{\code{fun}}{`string` or `function` operation to be applied at the
step. Both existing and lambda/anonymous functions can be used.}

\item{\code{params}}{`list` list of parameters to overwrite default
parameters of existing functions.}

\item{\code{description}}{`string` optional description of the step}

\item{\code{group}}{`string` grouping information (by default the same as
the name of the step. Any output collected later (see function
`collect_out` by default is put together by these group names. This,
for example, comes in handy when the pipeline is copy-appended
multiple times to keep the results of the same function/step at one
place.}

\item{\code{keepOut}}{`logical` if `FALSE` the output of the function will
be cleaned at the end of the whole pipeline execution. This option
is used to only keep the results that matter.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the `Pipeline` object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-set_common_parameters"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-set_common_parameters}{}}}
\subsection{Method \code{set_common_parameters()}}{
Set parameters in the pipeline. If a parameter occurs
in several steps, the parameter is set commonly in all steps.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$set_common_parameters(params, warnUndefined = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{params}}{`list` of parameters to be set}

\item{\code{warnUndefined}}{`logical` whether to give a warning if a
parameter is not defined in the pipeline.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the `Pipeline` object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-set_data"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-set_data}{}}}
\subsection{Method \code{set_data()}}{
Set data in first step of pipeline.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$set_data(data)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{`data.frame` initial data set.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the `Pipeline` object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-set_data_split"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-set_data_split}{}}}
\subsection{Method \code{set_data_split()}}{
Split-copy pipeline by list of data sets
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$set_data_split(
  dataList,
  to_step = utils::tail(self$get_step_names(), 1),
  groupBySplit = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataList}}{`list` of data sets}

\item{\code{to_step}}{`string` step name marking optional subset of
the pipeline, at which the data split should be applied to.}

\item{\code{groupBySplit}}{`logical` whether to set step groups according
to data split.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
new combined `Pipeline` with each sub-pipeline having set
one of the data sets.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-set_parameters_at_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-set_parameters_at_step}{}}}
\subsection{Method \code{set_parameters_at_step()}}{
Set unbound parameter values at given pipeline step.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$set_parameters_at_step(name, params)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{`string` the name of the step}

\item{\code{params}}{`list` of parameters to be set}

\item{\code{warnUndefined}}{`logical` whether to give a warning if a
parameter is not defined in the pipeline.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the `Pipeline` object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-clone"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
