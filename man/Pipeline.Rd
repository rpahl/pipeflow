% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pipeflow_pipeline.R
\docType{class}
\name{Pipeline}
\alias{Pipeline}
\title{Pipeline Class}
\description{
This class implements an analysis pipeline. A pipeline consists
of a sequence of analysis steps, which can be added one by one. Each added
step may or may not depend on one or more previous steps. The pipeline
keeps track of the dependencies among these steps and will ensure that
all dependencies are met on creation of the pipeline, that is, before the
the pipeline is executed. Once the pipeline is executed, the output is
stored in the pipeline along with each step and can be accessed later.
Different pipelines can be bound together while preserving all dependencies
within each pipeline.
}
\author{
Roman Pahl
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{name}}{\code{string} name of the pipeline}

\item{\code{pipeline}}{\code{data.table} the pipeline where each row represents on step.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-Pipeline-new}{\code{Pipeline$new()}}
\item \href{#method-Pipeline-add}{\code{Pipeline$add()}}
\item \href{#method-Pipeline-append}{\code{Pipeline$append()}}
\item \href{#method-Pipeline-append_to_step_names}{\code{Pipeline$append_to_step_names()}}
\item \href{#method-Pipeline-clean_out_at_step}{\code{Pipeline$clean_out_at_step()}}
\item \href{#method-Pipeline-collect_out}{\code{Pipeline$collect_out()}}
\item \href{#method-Pipeline-discard_steps}{\code{Pipeline$discard_steps()}}
\item \href{#method-Pipeline-execute}{\code{Pipeline$execute()}}
\item \href{#method-Pipeline-execute_step}{\code{Pipeline$execute_step()}}
\item \href{#method-Pipeline-get_data}{\code{Pipeline$get_data()}}
\item \href{#method-Pipeline-get_dependencies}{\code{Pipeline$get_dependencies()}}
\item \href{#method-Pipeline-get_downstream_dependencies}{\code{Pipeline$get_downstream_dependencies()}}
\item \href{#method-Pipeline-get_out_at_step}{\code{Pipeline$get_out_at_step()}}
\item \href{#method-Pipeline-get_parameters}{\code{Pipeline$get_parameters()}}
\item \href{#method-Pipeline-get_parameters_at_step}{\code{Pipeline$get_parameters_at_step()}}
\item \href{#method-Pipeline-get_parameters_unique}{\code{Pipeline$get_parameters_unique()}}
\item \href{#method-Pipeline-get_parameters_unique_json}{\code{Pipeline$get_parameters_unique_json()}}
\item \href{#method-Pipeline-get_step}{\code{Pipeline$get_step()}}
\item \href{#method-Pipeline-get_step_names}{\code{Pipeline$get_step_names()}}
\item \href{#method-Pipeline-get_step_number}{\code{Pipeline$get_step_number()}}
\item \href{#method-Pipeline-get_upstream_dependencies}{\code{Pipeline$get_upstream_dependencies()}}
\item \href{#method-Pipeline-has_out_at_step}{\code{Pipeline$has_out_at_step()}}
\item \href{#method-Pipeline-has_step}{\code{Pipeline$has_step()}}
\item \href{#method-Pipeline-keep_all_out}{\code{Pipeline$keep_all_out()}}
\item \href{#method-Pipeline-length}{\code{Pipeline$length()}}
\item \href{#method-Pipeline-print}{\code{Pipeline$print()}}
\item \href{#method-Pipeline-pop_step}{\code{Pipeline$pop_step()}}
\item \href{#method-Pipeline-pop_steps_after}{\code{Pipeline$pop_steps_after()}}
\item \href{#method-Pipeline-pop_steps_from}{\code{Pipeline$pop_steps_from()}}
\item \href{#method-Pipeline-remove_step}{\code{Pipeline$remove_step()}}
\item \href{#method-Pipeline-replace_step}{\code{Pipeline$replace_step()}}
\item \href{#method-Pipeline-set_data}{\code{Pipeline$set_data()}}
\item \href{#method-Pipeline-set_data_split}{\code{Pipeline$set_data_split()}}
\item \href{#method-Pipeline-set_keep_out}{\code{Pipeline$set_keep_out()}}
\item \href{#method-Pipeline-set_parameters}{\code{Pipeline$set_parameters()}}
\item \href{#method-Pipeline-set_parameters_at_step}{\code{Pipeline$set_parameters_at_step()}}
\item \href{#method-Pipeline-clone}{\code{Pipeline$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-new"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-new}{}}}
\subsection{Method \code{new()}}{
constructor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$new(name, data = NULL, logger = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{the name of the Pipeline}

\item{\code{data}}{optional data used in the pipeline (can be set later)}

\item{\code{logger}}{logger to be used for logging.
If you want to use your own custom log function, you need to
provide a function with the following signature:
\verb{function(level, msg, ...)}. The \code{level} argument is a
string, which can be one of \code{info}, \code{warn}, or \code{error}. The \code{msg}
argument is a string containing the message to be logged. The
\code{...} argument is a list of named parameters, which can be used to
add additional information to the log message. If no logger is
provided, the default logger is used. Note that with the
default logger, the log layout can be altered any time via
\code{\link[=set_log_layout]{set_log_layout()}}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-add"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-add}{}}}
\subsection{Method \code{add()}}{
Add pipeline step
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$add(
  step,
  fun,
  params = list(),
  description = "",
  group = step,
  keepOut = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} the name of the step. Each step name must
be unique.}

\item{\code{fun}}{\code{function} or name of the function to be applied at
the step. Both existing and lambda/anonymous functions can be used.}

\item{\code{params}}{\code{list} list of parameters to set or overwrite
parameters of the passed function.}

\item{\code{description}}{\code{string} optional description of the step}

\item{\code{group}}{\code{string} output collected after pipeline execution
(see function \code{collect_out}) is grouped by the defined group
names. By default, this is the name of the step, which comes in
handy when the pipeline is copy-appended multiple times to keep
the results of the same function/step grouped at one place.}

\item{\code{keepOut}}{\code{logical} if \code{FALSE} the output of the function will
be cleaned at the end of the whole pipeline execution. This option
is used to only keep the results that matter.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-append"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-append}{}}}
\subsection{Method \code{append()}}{
Append another pipeline. The append takes care of name
clashes and dependencies, which will be changed after the append.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$append(p, outAsIn = FALSE, sep = ".")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{p}}{\code{Pipeline} object to be appended.}

\item{\code{outAsIn}}{\code{logical} if \code{TRUE}, output of first pipeline is used}

\item{\code{sep}}{\code{string} separator used when updating step names to
prevent name clashes.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns new combined \code{Pipeline}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-append_to_step_names"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-append_to_step_names}{}}}
\subsection{Method \code{append_to_step_names()}}{
Append string to all step names. Also takes care
of updating dependencies accordingly.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$append_to_step_names(postfix, sep = ".")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{postfix}}{\code{string} to be appended to each step name.}

\item{\code{sep}}{\code{string} separator between step name and postfix.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-clean_out_at_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-clean_out_at_step}{}}}
\subsection{Method \code{clean_out_at_step()}}{
Clean output of given step.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$clean_out_at_step(step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-collect_out"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-collect_out}{}}}
\subsection{Method \code{collect_out()}}{
Collect all output that was stored and kept during the
pipeline execution.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$collect_out(groupBy = "group")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{groupBy}}{\code{string} column of pipeline by which to group the
output.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{list} containing the output, named after the groups, which,
by default, are the steps.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-discard_steps"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-discard_steps}{}}}
\subsection{Method \code{discard_steps()}}{
Discard all steps that match the given \code{pattern}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$discard_steps(pattern, recursive = FALSE, fixed = TRUE, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pattern}}{\code{string} containing a regular expression (or
character string for \code{fixed = TRUE}) to be matched.}

\item{\code{recursive}}{\code{logical} if \code{TRUE} the step is removed together
with all its downstream dependencies.}

\item{\code{fixed}}{\code{logical} If \code{TRUE}, \code{pattern} is a string to
be matched as is. Overrides all conflicting arguments.}

\item{\code{...}}{further arguments passed to \code{\link[=grep]{grep()}}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-execute"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-execute}{}}}
\subsection{Method \code{execute()}}{
Execute all pipeline steps.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$execute(from = 1, to = self$length(), recursive = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{from}}{\code{numeric} start from this step}

\item{\code{to}}{\code{numeric} execute until this step}

\item{\code{recursive}}{\code{logical} if \code{TRUE} and a step returns a new
pipeline, the run of the current pipeline is aborted and the
new pipeline is executed recursively.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-execute_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-execute_step}{}}}
\subsection{Method \code{execute_step()}}{
Execute given pipeline step
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$execute_step(step, upstream = TRUE, downstream = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}

\item{\code{upstream}}{\code{logical} if \code{TRUE}, execute all dependent upstream
steps first.}

\item{\code{downstream}}{\code{logical} if \code{TRUE}, execute all depdendent
downstream afterwards.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_data"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_data}{}}}
\subsection{Method \code{get_data()}}{
Get data currently loaded into the pipeline at step 1.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_data()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
returns the data
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_dependencies"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_dependencies}{}}}
\subsection{Method \code{get_dependencies()}}{
Get all dependencies defined in the pipeline
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_dependencies()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
named \code{list} of dependencies for each step
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_downstream_dependencies"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_downstream_dependencies}{}}}
\subsection{Method \code{get_downstream_dependencies()}}{
Get all downstream dependencies of given step, by
default descending recursively.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_downstream_dependencies(step, recursive = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}

\item{\code{recursive}}{\code{logical} if \code{TRUE}, dependencies of dependencies
are also returned.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{list} of downstream dependencies
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_out_at_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_out_at_step}{}}}
\subsection{Method \code{get_out_at_step()}}{
Get output of given step.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_out_at_step(step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_parameters"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_parameters}{}}}
\subsection{Method \code{get_parameters()}}{
Get all function parameters defined in the pipeline.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_parameters(ignoreHidden = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ignoreHidden}}{\code{logical} if TRUE, hidden parameters (i.e. all
names starting with a dot) are ignored and thus not returned.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{list} of parameters, sorted and named by step. Steps with
no parameters are filtered out.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_parameters_at_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_parameters_at_step}{}}}
\subsection{Method \code{get_parameters_at_step()}}{
Get all function parameters at given step name.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_parameters_at_step(step, ignoreHidden = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}

\item{\code{ignoreHidden}}{\code{logical} if TRUE, hidden parameters (i.e. all
names starting with a dot) are ignored and thus not returned.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{list} of parameters defined at given step.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_parameters_unique"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_parameters_unique}{}}}
\subsection{Method \code{get_parameters_unique()}}{
Get all function parameters defined in the pipeline,
but only list each parameter once. The values of the parameters,
will be the values of the first step where the parameter was defined.
This is particularly useful after the parameters where set using
the \code{set_parameters} function, which will set the same value
for all steps.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_parameters_unique(ignoreHidden = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ignoreHidden}}{\code{logical} if TRUE, hidden parameters (i.e. all
names starting with a dot) are ignored and thus not returned.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{list} of unique parameters
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_parameters_unique_json"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_parameters_unique_json}{}}}
\subsection{Method \code{get_parameters_unique_json()}}{
Get all unique function parameters in json format.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_parameters_unique_json(ignoreHidden = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ignoreHidden}}{\code{logical} if TRUE, hidden parameters (i.e. all
names starting with a dot) are ignored and thus not returned.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{list} flat unnamed json list of unique function parameters,
at this point with no information of the steps were parameters are
defined first.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_step}{}}}
\subsection{Method \code{get_step()}}{
Get step of pipeline
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_step(step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{data.table} row containing the step. If step not found, an
error is given.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_step_names"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_step_names}{}}}
\subsection{Method \code{get_step_names()}}{
Get step names of pipeline
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_step_names()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{character} vector of step names
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_step_number"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_step_number}{}}}
\subsection{Method \code{get_step_number()}}{
Get step number
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_step_number(step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the step number in the pipeline
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-get_upstream_dependencies"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-get_upstream_dependencies}{}}}
\subsection{Method \code{get_upstream_dependencies()}}{
Get all upstream dependencies of given step, by
default descending recursively.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$get_upstream_dependencies(step, recursive = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}

\item{\code{recursive}}{\code{logical} if \code{TRUE}, dependencies of dependencies
are also returned.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{list} of upstream dependencies
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-has_out_at_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-has_out_at_step}{}}}
\subsection{Method \code{has_out_at_step()}}{
Checks whether step has output.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$has_out_at_step(step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{logical} TRUE if step is defined to keep output
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-has_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-has_step}{}}}
\subsection{Method \code{has_step()}}{
Determine whether pipeline has given step.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$has_step(step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{logical} whether step exists
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-keep_all_out"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-keep_all_out}{}}}
\subsection{Method \code{keep_all_out()}}{
Set pipeline to keep all output regardless of the flags
that were set for the individual steps. This can be useful for
debugging.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$keep_all_out()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-length"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-length}{}}}
\subsection{Method \code{length()}}{
Length of the pipeline aka number of pipeline steps.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$length()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{numeric} length of pipeline.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-print"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-print}{}}}
\subsection{Method \code{print()}}{
Print the pipeline.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-pop_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-pop_step}{}}}
\subsection{Method \code{pop_step()}}{
Remove last step from the pipeline.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$pop_step()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
\code{string} the name of the step that was removed
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-pop_steps_after"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-pop_steps_after}{}}}
\subsection{Method \code{pop_steps_after()}}{
Remove all steps after the given step.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$pop_steps_after(step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{character} vector of steps that were removed.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-pop_steps_from"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-pop_steps_from}{}}}
\subsection{Method \code{pop_steps_from()}}{
Remove all steps from and including the given step.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$pop_steps_from(step)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{character} vector of steps that were removed.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-remove_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-remove_step}{}}}
\subsection{Method \code{remove_step()}}{
Remove certain step from the pipeline. If step does
not exist, an error is given. If other steps depend on the step to
be removed, an error is given, unless \code{recursive = TRUE}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$remove_step(step, recursive = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} the name of the step to be removed.}

\item{\code{recursive}}{\code{logical} if \code{TRUE} the step is removed together
with all its downstream dependencies.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-replace_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-replace_step}{}}}
\subsection{Method \code{replace_step()}}{
Replace pipeline step
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$replace_step(
  step,
  fun,
  params = list(),
  description = "",
  group = step,
  keepOut = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} the name of the step to be replaced. Step must
exist.}

\item{\code{fun}}{\code{string} or \code{function} operation to be applied at the
step. Both existing and lambda/anonymous functions can be used.}

\item{\code{params}}{\code{list} list of parameters to overwrite default
parameters of existing functions.}

\item{\code{description}}{\code{string} optional description of the step}

\item{\code{group}}{\code{string} grouping information (by default the same as
the name of the step. Any output collected later (see function
\code{collect_out} by default is put together by these group names. This,
for example, comes in handy when the pipeline is copy-appended
multiple times to keep the results of the same function/step at one
place.}

\item{\code{keepOut}}{\code{logical} if \code{FALSE} the output of the function will
be cleaned at the end of the whole pipeline execution. This option
is used to only keep the results that matter.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-set_data"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-set_data}{}}}
\subsection{Method \code{set_data()}}{
Set data in first step of pipeline.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$set_data(data)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{\code{data.frame} initial data set.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-set_data_split"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-set_data_split}{}}}
\subsection{Method \code{set_data_split()}}{
Split-copy pipeline by list of data sets. Each
sub-pipeline will have one of the data sets set as input data.
The step names of the sub-pipelines will be the original step names
plus the name of the data set.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$set_data_split(
  dataList,
  to_step = utils::tail(self$get_step_names(), 1),
  groupBySplit = TRUE,
  sep = "."
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dataList}}{\code{list} of data sets}

\item{\code{to_step}}{\code{string} step name marking optional subset of
the pipeline, at which the data split should be applied to.}

\item{\code{groupBySplit}}{\code{logical} whether to set step groups according
to data split.}

\item{\code{sep}}{\code{string} separator to be used between step name and
data set name when creating the new step names.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
new combined \code{Pipeline} with each sub-pipeline having set
one of the data sets.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-set_keep_out"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-set_keep_out}{}}}
\subsection{Method \code{set_keep_out()}}{
Set pipeline to keep or omit output of given step.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$set_keep_out(step, status = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} name of step}

\item{\code{status}}{\code{logical} whether to keep output of step}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-set_parameters"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-set_parameters}{}}}
\subsection{Method \code{set_parameters()}}{
Set parameters in the pipeline. If a parameter occurs
in several steps, the parameter is set commonly in all steps.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$set_parameters(params, warnUndefined = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{params}}{\code{list} of parameters to be set}

\item{\code{warnUndefined}}{\code{logical} whether to give a warning if a
parameter is not defined in the pipeline.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-set_parameters_at_step"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-set_parameters_at_step}{}}}
\subsection{Method \code{set_parameters_at_step()}}{
Set unbound parameter values at given pipeline step.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$set_parameters_at_step(step, params)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{step}}{\code{string} the name of the step}

\item{\code{params}}{\code{list} of parameters to be set}

\item{\code{warnUndefined}}{\code{logical} whether to give a warning if a
parameter is not defined in the pipeline.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns the \code{Pipeline} object invisibly
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Pipeline-clone"></a>}}
\if{latex}{\out{\hypertarget{method-Pipeline-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Pipeline$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
