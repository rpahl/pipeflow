---
title: "Combining pipelines"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
description: >
  Shows how to combine different pipelines to a single pipeline.
vignette: >
  %\VignetteIndexEntry{Combining pipelines}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitr-setup, include = FALSE}
require(pipeflow)

knitr::opts_chunk$set(
  comment = "#",
  prompt = FALSE,
  tidy = FALSE,
  cache = FALSE,
  collapse = TRUE
)

old <- options(width = 100L)
library(ggplot2)
```

The possibility to combine pipelines basically allows to modularize the pipeline
creation process. This is especially useful when you have a set of pipelines that are
used in different contexts and you want to avoid code duplication.

In this vignette we will also introduce the pipeflow alias functions, that is,
for each member function of a pipeline, there is an alias function, which allows to
work with R's native pipe operator `|>`. For example, the `add` function has an alias
`pipe_add` (see below).


### Define two pipelines

Let's define one pipeline that is used for data preprocessing and one that does the
modeling.

Data preprocessing pipeline:
```{r define-prepocessing-pipeline}
pip1 <- pipe_new("preprocessing", data = airquality) |>

    pipe_add(
        "data prep",
        function(data = ~data) {
            replace(data, "Temp.Celsius", (data[, "Temp"] - 32) * 5/9)
        }
    ) |>

    pipe_add(
        "standardize",
        function(data = ~`data prep`, yVar = "Ozone") {
            data[, yVar] <- scale(data[, yVar])
            data
        }
    )
```

```{r}
pip1
```


Modeling pipeline:
```{r define-modeling-pipeline}
pip2 <- pipe_new("modeling", data = airquality) |>

    pipe_add(
        "model fit",
        function(
            data = ~data,
            xVar = "Temp",
            yVar = "Ozone"
        ) {
            lm(paste(yVar, "~", xVar), data = data)
        }
    ) |>

    pipe_add(
        "model plot",
        function(
            model = ~`model fit`,
            data = ~data,
            xVar = "Temp",
            yVar = "Ozone",
            title = "Linear model fit"
        ) {
            coeffs <- coefficients(model)
            ggplot(data) +
                geom_point(aes(.data[[xVar]], .data[[yVar]])) +
                geom_abline(intercept = coeffs[1], slope = coeffs[2]) +
                labs(title = title)
        }
    )
```


```{r}
pip2
```


### Combine pipelines

Next we combine the two pipelines. We can do this by using the `append` function.

```{r}
pip <- pip1$append(pip2)

pip
```

First note that all steps and dependencies of the second pipeline have been appended
with the name of the second pipeline (lines 4-6). For example, the first step of the second pipeline has been renamed from `data` to `data.modeling` (line 4).
This is always done when appending a pipeline to avoid any name clashes in case the
two pipelines have steps with the same name.

To make actual use of the combined pipeline, we want to use the output of the first
pipeline as input of the second pipeline, that is, we want to use the standardized
data in the modeling pipeline.
One way to achieve this would be to use the `replace` function as described earlier
in the vignette [modify the pipeline](modify-pipeline.html), for example:

```{r}
pip$replace_step("data.modeling", function(data = ~standardize) data)

pip
```


#### Relative indexing

Since the name of the last step might not always be known^[A typical example would
be appending several pipelines in a programmatic context.], the `pipeflow` package
also provides a relative position indexing mechanism, which allows to rewrite the
above command as follows:

```{r}
pip$replace_step("data.modeling", function(data = ~-1) data)

pip
```

Generally speaking, the relative indexing mechanism allows to refer to steps postioned
above the current step. The index `~-1` can be interpreted as "go one step back", `~-2`
as "go two steps back", and so on.

Since this scenario of connecting two pipelines is so common and to avoid the need
to replace the output of the first pipeline manually, the `append` function has an
argument `outAsIn` that allows to do appending and "connecting" both pipelines in one go:

```{r}
pip <- pip1$append(pip2, outAsIn = TRUE)

pip
```

If we inspect the `data.modeling` step, we see that indeed the original step has been
replaced by the output of the last step of the first pipeline using the relative
indexing mechanism.

```{r}
pip$get_step("data.modeling")[["fun"]]
```

### Run combined pipeline

Let's now run the combined pipeline and inspect the plot.

```{r}
pip$run()
```

```{r}
pip$get_out("model plot.modeling")
```

As we can see, the plot shows the linear model fit using the standardized data.
We can now go ahead and for example change the x-variable of the model and rerun the
pipeline.

```{r}
pip$set_params(list(xVar = "Temp.Celsius"))
pip$run()
```

```{r}
pip$get_out("model plot.modeling")
```

When creating these pipelines, usually there will be a lot of steps calculating
intermediate results and only a few steps contain the final results that we are
interested in. In the above example, we were interested in the final output of the
To see how to conveniently collect and possibly group the output of those final
steps, see the next vignette [Collecting output](collect-output.html).

```{r, include = FALSE}
options(old)
```
