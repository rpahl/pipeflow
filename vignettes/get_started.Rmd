---
title: "Get started with pipeflow"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 4
description: >
  Start here if this is your first time using pipeflow.
vignette: >
  %\VignetteIndexEntry{Get started with pipeflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitr-setup, include = FALSE}
require(pipeflow)

knitr::opts_chunk$set(
  comment = "#",
  prompt = F,
  tidy = FALSE,
  cache = FALSE,
  collapse = T
)

old <- options(width = 100L)
```

## A simple example to get started
In this example, we'll use base R's airquality dataset.

```{r show-airquality}
head(airquality)
```

Our goal is to add a new column `Temp.Celsius` to the dataset, which contains
the temperature in degrees Celsius instead of Fahrenheit. We then want to fit
a linear model to the data and plot the data and the model fit. We'll use
pipeflow to do this in a reproducible way.

In the following, we'll show how to define and run the pipeline, how to inspect
the output of specifics steps, and finally how to rerun the pipeline with
different parameter settings, which is one of the selling points of using
such a pipeline.

### Define the pipeline

For easier understanding, we go step by step. First, we create a new pipeline
with the name "my-pipeline" and the airquality dataset as input data.

```{r define-pipeline}
library(pipeflow)
library(ggplot2)

pip <- Pipeline$new("my-pipeline", data = airquality)
```

Let's view the pipeline after initialization.
```{r show-initial-pipeline}
pip
```

So far, it just consists of one step called `data`, which is in state `New`.

Next, we add a step called `data prep`, which consists of a function that
takes the output of the `data` step as its first argument, adds a new column
and returns the modified data as its output. To refer to the output of a
specific pipeline step, we use the tilde (~) operator.

```{r define-data-prep-step}
pip$add(
    "data prep",
    function(data = ~data) {
        replace(data, "Temp.Celsius", (data[, "Temp"] - 32) * 5/9)
    }
)
```


Again, let's inspect the pipeline.
```{r show-pipeline-after-data-prep-was-added}
pip
```

A second step called `data prep` was added and it depends on the `data`
step as can be seen in column `depends`, which will list all dependencies of
a step.

Next, we add a step called `model fit`, which fits a linear model to the
data. The function takes the output of the `data prep` and defines a
parameter `xVar`, which is used to specify the variable that is used as
predictor in the linear model.

```{r}
pip$add(
    "model fit",
    function(data = ~`data prep`, xVar = "Temp.Celsius") {
        lm(paste("Ozone ~", xVar), data = data)
    }
)
```

Lastly, we add a step called `model plot`, which plots the data and the
linear model fit. The function uses the output from both the
`model fit` and the `data prep` step. It also defines the `xVar`
parameter and a parameter `title`, which is used as the title
of the plot.

```{r}
pip$add(
    "model plot",
    function(
        model = ~`model fit`,
        data = ~`data prep`,
        xVar = "Temp.Celsius",
        title = "Linear model fit"
    ) {
        coeffs <- coefficients(model)
        ggplot(data) +
            geom_point(aes(.data[[xVar]], .data[["Ozone"]])) +
            geom_abline(intercept = coeffs[1], slope = coeffs[2]) +
            labs(title = title)
    }
)
```

This completes our pipeline, which now looks as follows:
```{r show-completed-pipeline}
pip
```

In the last line, we see that the `model plot` step depends on both
the `model fit` and `data prep` step.


### Run the pipeline and inspect the output

To run the pipeline, we simply call the `run()` method on the pipeline,
which will produce the following output:

```{r run-pipeline}
pip$run()
```

Let's inspect the pipeline again.
```{r pipeline-after-run}
pip
```

We can see that the `state` of all steps have been changed from `New` to `Done`.
In addition, the output was added in the `out` column. We can inspect the
output of a specific step by calling the `get_out()` method on the pipeline.

```{r inspect-lm, message = FALSE}
pip$get_out("model fit")
```

```{r inspect-plot, message = FALSE, warning = FALSE}
pip$get_out("model plot")
```


### Change parameters of the pipeline

Any parameter of the pipeline that is *not* bound to a specific step
(i.e. is not defined with the tilde (~) operator) can be
changed by calling the `set_params()` method on the pipeline. Let's first
list all unbound parameters:

```{r inspect-params}
pip$get_params()
```

Now let's assume we want to change the `xVar` simultaneously for the
`model fit` and `model plot` steps. We can do this simply as follows:

```{r set-xVar}
pip$set_params(list(xVar = "Solar.R"))
pip$get_params()
```

Changing the parameters of the pipeline at least has an effect on all
steps that depend on the changed parameter.

```{r show-pipeline-with-outdated-step}
pip
```

We can see that the `model fit` and `model plot` steps are now in state
`Outdated`, which means that they need to be rerun. We can do this by
calling the `run()` method on the pipeline again.

```{r run-pipeline-again}
pip$run()
```

The outdated steps were re-run as expected and the output was
updated accordingly.

```{r inspect-plot-again, message = FALSE, warning = FALSE}
pip$get_out("model plot")
```

To just change the title of the plot, obviously only the `model plot` step
needs to be rerun.

```{r set-title}
pip$set_params(list(title = "Some new title"))
pip
```

```{r inspect-plot-after-title-change, message = FALSE, warning = FALSE}
pip$run()$get_out("model plot")
```

If instead we were to change the input data, since all steps depend on it,
we expect all steps to be rerun.

```{r}
pip$set_data(airquality[1:10, ])
pip
```

```{r inspect-plot-after-data-change, message = FALSE, warning = FALSE}
pip$run()$get_out("model plot")
```


```{r, include = FALSE}
options(old)
```
